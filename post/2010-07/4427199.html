<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="../../css/result.css">

        <title>RSA 기반 웹페이지 암호화 로그인</title>
    </head>
    <body>
        <section id="wrap">
            <header>
                <h1 class="logo-title">
                    <span class="main"><img src="../../images/logo_egloos.png" width="105" height="34" alt="이글루스"></span>
                </h1>
                <div class="user-info">
                    <strong class="name">권남</strong> 님 (<strong class="name">kwon37xi</strong>)
                </div>
            </header>
            <main>
                <article class="post-wrap">
                    <!-- 게시물 정보 : 날짜 -->
                    <div class="post-info">
                        <span class="time">2010-07-07 11:28:28</span>
                    </div>
                    <!-- 게시물 제목 -->
                    <h2 class="post-title">RSA 기반 웹페이지 암호화 로그인</h2>
                    <!-- 게시물 본문 -->
                    <div class="post-body">
                        <div class="content"><b>PS&gt;아래 내용은 보안상 검증된 것이 아닙니다. 잘 확인하고 사용하세요.</b><br><br><div class="xhtmlEditorBody"><h1>웹 페이지에서 SSL 없이 RSA 암호화 로그인 하기</h1> <p>사용자의 비밀번호를 전송할 때는 SSL 등의 처리를 하지 않으면 해당 비밀번호를 중간에 가로채서 보는 것이 가능하다. 그러나 비영리 싸이트 혹은 SSL 인증서 구매가 어려운 경우에 JavaScript로 RSA 암호화를 이용해서 암호화된 로그인이 가능하다.</p> <p>RSA는 비대칭 방식으로 암호화는 공개키(누구나 볼 수 있다)로 하고 복호화는 개인키를 가진쪽만 가능한 형태이다.</p> <p><strong>사용자가 로그인 폼을 채우면 사용자 ID와 비밀번호를 RSA 공개키로 암호화해서 전송하여, 중간에 패킷을 가로채도 해석이 불가능하게 만드는 것이다.</strong></p> <p>&nbsp;</p> <p>이와 같은 것을 구현하고 싶어진 계기는 회사 내부적으로 사용하는 운영용 싸이트의 로그인 정보를 암호화해야 겠다는 생각이 들었기 때문이다. 그러면서&nbsp; 돈 안 쓰고 특정 브라우저에 종속되지 않으면서도 안전한 사이트 이용을 가능하게 하는 방법을 찾다가 <a href="http://www.megabox.co.kr/" class="external" title="http://www.megabox.co.kr/">메가박스</a> 홈페이지가 2010년 6월 현재 SSL과 ActiveX없이 그렇게 구현돼 있는 것을 보았다.</p> <p>이와 같은 로그인 및 데이터 전송 방식에 대해서는 <a href="http://www.hackerbook.co.kr/books_info.php?book=3" title="http://www.hackerbook.co.kr/books_info.php?book=3" class="external">알아야 막는다 자바 JSP 해킹과 보안</a> 책에서 정보를 얻어서 <a href="http://www-cs-students.stanford.edu/%7Etjw/jsbn/" title="http://www-cs-students.stanford.edu/~tjw/jsbn/" class="external">BigIntegers and RSA in JavaScript</a> 라이브러리를 사용하였다.</p> <p>참고로 해당 라이브러리에서 제공하는 BASE64 인코더에 문제가 있는 것으로 보인다. 책에서 소개한대로 이 BASE64 인코딩 라이브러리를 사용하면 FireFox에서는 오동작을 한다. 그래서 BASE64를 사용하지 않고 암호화된 바이트 배열을 그냥 16진 문자열(hex)로 서버에 전송한다.</p> <p><a href="http://www.hackerbook.co.kr/books_info.php?book=3" title="http://www.hackerbook.co.kr/books_info.php?book=3" class="external">알아야 막는다 자바 JSP 해킹과 보안</a> 책의 방식대로 하면 세션에 무한정 PrivateKey를 저장해서 메모리 누수를 일으킬 수 있다. 이 책 그대로 따라하면 안된다.</p> <p>&nbsp;</p> <p>사실 그냥 HTTPS 사용하면 더 안전하게 아무 처리 없이 다 해결되는 문제들이다. 하지만 내부 적으로만 사용하는 서비스들에 대해서 일일이 다 인증서를 등록할 수는 없으니 지금 소개하는 방식이 가장 쉽고 돈 안들이면서 안전하게 로그인 할 수 있는 방법이 되어 줄 것이다.</p> <p>&nbsp;</p> <h3>기본 작동 원리</h3> <ol> <li>[서버] 서버측에서 RSA 공개키와 개인키(비밀키)를 생성하여, 개인키는 세션에 저장하고 공개키는 자바스크립트 로그인 폼이 있는 페이지로 출력한다.</li> <li>[클라이언트] 로그인폼은 자바스크립트가 실행되지 않는 환경에서는 발행(submit)이 되면 안된다.</li> <li> <p>[클라이언트] 로그인폼에 사용자의 ID와 비밀번호를 넣고 발행을 누르면 자바스크립트가 이를 가로챈다.</p> <ol> <li>사용자 ID를 RSA로 암호화하여 화면에 안보이는 새로운 폼에 저장한다.</li> <li>비밀번호를 RSA로 암호화하여 화면에 안보이는 새로운 폼에 저장한다.</li> <li>이제 화면에 안보이는 해당 폼을 서버로 발행한다.</li> </ol> </li> <li>[서버] 서버측에서 세션에 저장된 RSA개인키로 암호화된 사용자ID와 비밀번호를 복호화한다.</li> <li>[서버] 데이터베이스/혹은 기타 저장소에 저장된 사용자 ID와 비밀번호가 일치하는지 확인한다.</li> </ol> <p>&nbsp;</p> <p>주의할 점. 암호화 된 값은 byte 배열이다. 이를 문자열 폼으로 전송하기 위해 16진 문자열(hex)로 변경한다. 서버측에서도 값을 받을 때 hex 문자열을 받아서 이를 다시 byte 배열로 바꾼 뒤에 복호화 과정을 수행한다.</p> <p>&nbsp;</p> <h3>Java 로그인 폼 측 키생성</h3> <p>로그인 폼을 보여주는 화면을 출력할 때, 그와 동시에 공개키와 개인키를 생성해서 공개키는 HTML/Javascript에서 접근 가능하게 노출하고 개인키는 HTTP 세션에 보관하여 암호를 풀 때 사용하도록 처리한다.</p> <ol class="code"> <li>KeyPairGenerator generator = KeyPairGenerator.getInstance("RSA");<br> generator.initialize(KEY_SIZE);<br> <br> KeyPair keyPair = generator.genKeyPair();<br> KeyFactory keyFactory = KeyFactory.getInstance("RSA");<br> <br> <strong>PublicKey publicKey = keyPair.getPublic();<br> PrivateKey privateKey = keyPair.getPrivate();</strong><br> <br> HttpSession session = request.getSession();<br> // 세션에 공개키의 문자열을 키로하여 개인키를 저장한다.<br> <strong>session.setAttribute("__rsaPrivateKey__", privateKey);</strong><br> <br> // 공개키를 문자열로 변환하여 JavaScript RSA 라이브러리 넘겨준다.<br> RSAPublicKeySpec publicSpec = (RSAPublicKeySpec) keyFactory.getKeySpec(publicKey, RSAPublicKeySpec.class);<br> <br> String publicKeyModulus = publicSpec.getModulus().toString(16);<br> String publicKeyExponent = publicSpec.getPublicExponent().toString(16);<br> <br> request.setAttribute("publicKeyModulus", publicKeyModulus);<br> request.setAttribute("publicKeyExponent", publicKeyExponent);<br> <br> request.getRequestDispatcher("/WEB-INF/views/loginForm.jsp").forward(request, response);</li> </ol> <p>&nbsp;</p> <p>loginForm.jsp 에서 실제로 폼을 출력하는 역할을 한다.</p> <p>&nbsp;</p> <h3>HTML 폼</h3> <ol class="code"> <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;!-- script 태그에서 가져오는 자바스크립트 파일의 순서에 주의해야한다! 순서가 틀릴경우 자바스크립트 오류가 발생한다. --&gt;<br> <strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;script type="text/javascript" src="&lt;%=request.getContextPath()%&gt;/js/rsa/jsbn.js"&gt;&lt;/script&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;script type="text/javascript" src="&lt;%=request.getContextPath()%&gt;/js/rsa/rsa.js"&gt;&lt;/script&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;script type="text/javascript" src="&lt;%=request.getContextPath()%&gt;/js/rsa/prng4.js"&gt;&lt;/script&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;script type="text/javascript" src="&lt;%=request.getContextPath()%&gt;/js/rsa/rng.js"&gt;&lt;/script&gt;</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;script type="text/javascript" src="&lt;%=request.getContextPath()%&gt;/js/login.js"&gt;&lt;/script&gt;<br> &nbsp;&nbsp;&nbsp; &lt;/head&gt;<br> &nbsp;&nbsp;&nbsp; &lt;body&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;div&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;label for="username"&gt;사용자ID : &lt;input type="text" id="username" size="16"/&gt;&lt;/label&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;label for="password"&gt;비밀번호 : &lt;input type="password" id="password" size="16" /&gt;&lt;/label&gt;<br> <strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;input type="hidden" id="rsaPublicKeyModulus" value="&lt;%=publicKeyModulus%&gt;" /&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;input type="hidden" id="rsaPublicKeyExponent" value="&lt;%=publicKeyExponent%&gt;" /&gt;</strong><br> <strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;a href="&lt;%=request.getContextPath()%&gt;/loginFailure.jsp" onclick="validateEncryptedForm(); return false;"&gt;로그인&lt;/a&gt;</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/div&gt;<br> <strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;form id="securedLoginForm" name="securedLoginForm" action="&lt;%=request.getContextPath()%&gt;/login" method="post" style="display: none;"&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;input type="hidden" name="securedUsername" id="securedUsername" value="" /&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;input type="hidden" name="securedPassword" id="securedPassword" value="" /&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/form&gt;</strong><br> &nbsp;&nbsp;&nbsp; &lt;/body&gt;</li> </ol> <p>&nbsp;</p> <p>폼을 이중으로 만들었는데, 이유가 있다. 폼에 submit 버튼을 두게되면 사용자가 그냥 엔터를 쳐도 폼이 제출되게 된다. 이렇게 되면 사용자의 웹 브라우저가 Javascript를 지원하지 않아도 폼이 제출되므로 사용자가 쓴 아이디와 비밀번호가 그냥 전송되게 돼 버린다.</p> <p>사용자가 ID와 비밀번호를 친 뒤에 무조건 Javascript를 타게 만들기 위해 입력용 폼과 Javascript로 암호화하여 실제로 제출하는 폼을 분리한 것이다.</p> <p>만약 사용자의 브라우저가 javascript를 지원하지 않는다면, 로그인 링크의 loginFailure.jsp 페이지가 보여지게 된다.</p> <p>&nbsp;</p> <h3>자바스크립트 암호화 처리</h3> <ol class="code"> <li>function validateEncryptedForm() {<br> &nbsp;&nbsp;&nbsp; var username = document.getElementById("username").value;<br> &nbsp;&nbsp;&nbsp; var password = document.getElementById("password").value;<br> &nbsp;&nbsp;&nbsp; if (!username || !password) {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alert("ID/비밀번호를 입력해주세요.");<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br> &nbsp;&nbsp;&nbsp; }<br> <br> &nbsp;&nbsp;&nbsp; try {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var rsaPublicKeyModulus = document.getElementById("rsaPublicKeyModulus").value;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var rsaPublicKeyExponent = document.getElementById("rsaPublicKeyExponent").value;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; submitEncryptedForm(username,password, rsaPublicKeyModulus, rsaPublicKeyExponent);<br> &nbsp;&nbsp;&nbsp; } catch(err) {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alert(err);<br> &nbsp;&nbsp;&nbsp; }<br> &nbsp;&nbsp;&nbsp; return false;<br> }<br> <br> function <strong>submitEncryptedForm</strong>(username, password, rsaPublicKeyModulus, rsaPpublicKeyExponent) {<br> <strong>&nbsp;&nbsp;&nbsp; var rsa = new RSAKey();<br> &nbsp;&nbsp;&nbsp; rsa.setPublic(rsaPublicKeyModulus, rsaPpublicKeyExponent);<br> <br> &nbsp;&nbsp;&nbsp; // 사용자ID와 비밀번호를 RSA로 암호화한다.<br> &nbsp;&nbsp;&nbsp; var securedUsername = rsa.encrypt(username);<br> &nbsp;&nbsp;&nbsp; var securedPassword = rsa.encrypt(password);<br> <br> &nbsp;&nbsp;&nbsp; // POST 로그인 폼에 값을 설정하고 발행(submit) 한다.<br> &nbsp;&nbsp;&nbsp; var securedLoginForm = document.getElementById("securedLoginForm");<br> &nbsp;&nbsp;&nbsp; securedLoginForm.securedUsername.value = securedUsername;<br> &nbsp;&nbsp;&nbsp; securedLoginForm.securedPassword.value = securedPassword;<br> &nbsp;&nbsp;&nbsp; securedLoginForm.submit();</strong></li> </ol> <p>&nbsp;</p> <p>&nbsp;</p> <p>실질적인 암호화는 submitEncryptedForm에서 이뤄진다. 공개키의 rsaPublicKeyModulus와 rsaPublicKeyExponent 값을 읽어 RSA 객체를 구성하고 이를 가지고 사용자의 ID와 비밀번호를 모두 암호화하여 전송용 폼에 암호화된 값을 지정하고 폼을 제출(submit)한다.</p> <p>&nbsp;</p> <h3>Java 측 복호화하여 사용자 ID,비밀번호 확인</h3> <ol class="code"> <li>&nbsp;&nbsp;&nbsp; /**<br> &nbsp;&nbsp;&nbsp;&nbsp; * 암호화된 비밀번호를 복호화 한다.<br> &nbsp;&nbsp;&nbsp;&nbsp; */<br> &nbsp;&nbsp;&nbsp; protected void processRequest(HttpServletRequest request, HttpServletResponse response)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throws ServletException, IOException {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String securedUsername = request.getParameter("securedUsername");<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String securedPassword = request.getParameter("securedPassword");<br> <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HttpSession session = request.getSession();<br> <strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PrivateKey privateKey = (PrivateKey) session.getAttribute("</strong><span style="font-weight: bold;">__rsaPrivateKey__</span><strong>");<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; session.removeAttribute("__rsaPrivateKey__"); // 키의 재사용을 막는다. 항상 새로운 키를 받도록 강제.</strong><br> <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (privateKey == null) {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new RuntimeException("암호화 비밀키 정보를 찾을 수 없습니다.");<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String username = decryptRsa(privateKey, securedUsername);<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String password = decryptRsa(privateKey, securedPassword);<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; request.setAttribute("username", username);<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; request.setAttribute("password", password);<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; request.getRequestDispatcher("/WEB-INF/views/login.jsp").forward(request, response);<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch (Exception ex) {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new ServletException(ex.getMessage(), ex);<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br> &nbsp;&nbsp;&nbsp; }<br> <br> <strong>&nbsp;&nbsp;&nbsp; private String decryptRsa(PrivateKey privateKey, String securedValue) throws Exception {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("will decrypt : " + securedValue);<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Cipher cipher = Cipher.getInstance("RSA");<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte[] encryptedBytes = hexToByteArray(securedValue);<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cipher.init(Cipher.DECRYPT_MODE, privateKey);<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte[] decryptedBytes = cipher.doFinal(encryptedBytes);<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String decryptedValue = new String(decryptedBytes, "utf-8"); // 문자 인코딩 주의.<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return decryptedValue;<br> &nbsp;&nbsp;&nbsp; }</strong><br> <br> &nbsp;&nbsp;&nbsp; /**<br> &nbsp;&nbsp;&nbsp;&nbsp; * 16진 문자열을 byte 배열로 변환한다.<br> &nbsp;&nbsp;&nbsp;&nbsp; */<br> &nbsp;&nbsp;&nbsp; public static byte[] hexToByteArray(String hex) {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (hex == null || hex.length() % 2 != 0) {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return new byte[]{};<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br> <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte[] bytes = new byte[hex.length() / 2];<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; hex.length(); i += 2) {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte value = (byte)Integer.parseInt(hex.substring(i, i + 2), 16);<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bytes[(int) Math.floor(i / 2)] = value;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return bytes;<br> &nbsp;&nbsp;&nbsp; }</li> </ol> <p>&nbsp;</p> <p>사용자의 로그인 정보를 받아서 실제 사용자가 맞는지 확인하는쪽 컨트롤러이다. 여기서는 그냥 사용자의 입력을 화면에 다시 출력해주도록 만들었다.</p> <p>HTTP 세션에서 앞서 저장한 개인키를 읽는다. 만약 변조된 공개키로 암호화를 했거나 개인키가 존재하지 않는 상황이라면 물론 오류가 발생한다.</p> <p>그리고 세션에서 개인키를 지워버린다. 절대로 동일 개인키로 두 번이상 로그인 할 수 없게 만들었다.</p> <p>&nbsp;</p> <h3>어떻게 전송되나</h3> <p>아래 이미지는 실제 전송되는 데이터를 <a href="http://www.charlesproxy.com/" class="external" title="http://www.charlesproxy.com/">Charles</a> 라는 HTTP 프록시 툴로 살펴본 것이다. 사용자의 ID와 비밀번호가 모두 암호화되어 원형을 알아 볼 수 없음을 볼 수 있다.</p> <p>&nbsp;</p> <p><img src='./4427199/b0046915_52119ff4c732a.png'></p> <p>&nbsp;</p> <p>이상이 끝. 관련 파일을 모두 함께 올려둔다. WAR 는 실행하고서 <a href="http://localhost:8080/RSATest/" class="external" title="http://localhost:8080/RSATest/">http://localhost:8080/RSATest</a> 로 접속하면 된다.</p> <p><br></p><p><a href='http://pds27.egloos.com/pds/201308/19/15//RSATest.war' target='_blank'>RSATest.war</a><a href="http://kwon37xi.springnote.com/pages/5997243/attachments/3562739" title="LoginFormServlet.java" class="attachment"></a></p> <p>&nbsp;</p> <h3>기타</h3> <p>사실 정말로 원한 것은 AES로 사용자의 정보를 암호화하고 AES키를 RSA공개키로 암호화하여 서버에 전달 한뒤, 서버에서 RSA 개인키로 AES키를 복호화해 알아내고, 그 AES키로 다시 사용자 정보를 복호화하는 이중 암호화를 시도했었다.</p> <p>그러나 그닥 녹록치 않아서, 일단&nbsp;RSA 기반의 단일 암호화로 만족한 상태이다.</p> <p>&nbsp;</p> <p style="text-align: right;">이 글은 <a href="http://kwon37xi.springnote.com/">스프링노트</a>에서 작성되었습니다.</p></div></div>
                        <div class="post-footer">
                            <button class="btn" onclick="button_click();">목록</button>
                        </div>
                    </div>
                </article>
            </main>
        </section>

        <script src="https://code.jquery.com/jquery-3.5.1.js"></script>

        <script>
            function button_click() {
                if(history.length > 1) {
                    history.back();
                } else {
                    document.location.href = "../../블로그포스트목록.html";
                }
            }
        </script>
    </body>
</html>
