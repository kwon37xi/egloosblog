<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="../../css/result.css">

        <title>[JDBC] Java Database Programming 정리</title>
    </head>
    <body>
        <section id="wrap">
            <header>
                <h1 class="logo-title">
                    <span class="main"><img src="../../images/logo_egloos.png" width="105" height="34" alt="이글루스"></span>
                </h1>
                <div class="user-info">
                    <strong class="name">권남</strong> 님 (<strong class="name">kwon37xi</strong>)
                </div>
            </header>
            <main>
                <article class="post-wrap">
                    <!-- 게시물 정보 : 날짜 -->
                    <div class="post-info">
                        <span class="time">2006-06-22 08:53:30</span>
                    </div>
                    <!-- 게시물 제목 -->
                    <h2 class="post-title">[JDBC] Java Database Programming 정리</h2>
                    <!-- 게시물 본문 -->
                    <div class="post-body">
                        <div class="content"><div class="h1">JDBC</div><br> * <a title="" href="http://www.aladdin.co.kr/shop/wproduct.aspx?ISBN=8931425864">Java Database Programming</a> 책 정리<br> * 책 평가는 - 그냥 그래...<br> * 이것은 JDBC를 설명하기 위한 것이 아니라, 필요할 때 찾아봐서 기억을 상기 시키려는 목적으로 작성되었으므로, 이것만 봐서는 JDBC를 이해할 수 없음. 책을 읽거나 다른 JDBC관련 기초 설명을 봐야 이해할 수 있음.<br> * 현재 JDBC 3.0을 지원하는 드라이버는 거의 없다. 그러므로 JDBC 3.0으로 표기된 것들은 작동하지 않는다.<br> * JDBC 관련 문서 : <a title="" href="http://java.sun.com/j2se/1.4.2/docs/guide/jdbc/">http://java.sun.com/j2se/1.4.2/docs/guide/jdbc/</a><br><div class="h2">DriverManager를 이용한 Connection 획득</div><br><blockquote class="src">Class.forName("myDriver.className");<br>Connection&nbsp;conn&nbsp;=&nbsp;DriverManager.getConnection(<br>&nbsp;&nbsp;&nbsp;&nbsp;"jdbc:myprotocol:mydatabase",<br>&nbsp;&nbsp;&nbsp;&nbsp;"id",<br>&nbsp;&nbsp;&nbsp;&nbsp;"password");<br></blockquote><br><br><div class="h2">DataSource를 이용한 Connection 획득</div><br><blcokquote class="src">Context&nbsp;ctx&nbsp;=&nbsp;new&nbsp;InitialContext();<br>//&nbsp;이&nbsp;객체가&nbsp;JNDI에&nbsp;미리&nbsp;등록되어&nbsp;있어야만&nbsp;한다.<br>DataSource&nbsp;ds&nbsp;=&nbsp;(DataSource)ctx.lookup("jdbc/bookSampleDB");<br><br>Connection&nbsp;con&nbsp;=&nbsp;ds.getConnection("id",&nbsp;"password");<br></blockquote><br><br><div class="h2">ConnectionPoolDataSource를 이용한 커넥션풀에서 Connection 획득. JDBC 3.0</div><br><blockquote class="src">Context&nbsp;ctx&nbsp;=&nbsp;new&nbsp;InitialContext();<br>DataSource&nbsp;ds&nbsp;=&nbsp;(DataSource)ctx.lookup("jdbc/poolconnectionbookds");<br><br>Connection&nbsp;con&nbsp;=&nbsp;ds.getConnection("id",&nbsp;"password");<br></blockquote><br><br><div class="h2">Statement : SQL명령문을 실행한다.</div><br>Statement, PreparedStatement, CallableStatement 세 종류가 있다.<br><br><div class="h2">Statement 얻기</div><br><blockquote class="src">Connection&nbsp;conn&nbsp;=&nbsp;ds.getConnection("id",&nbsp;"password");<br>Statement&nbsp;stmt1&nbsp;=&nbsp;conn.createStatement();<br>Statement&nbsp;stmt2&nbsp;=&nbsp;conn.createStatement();<br>&nbsp;&nbsp;&nbsp;&nbsp;....<br>stmt1.close();<br>stmt2.close();<br></blockquote><br>&nbsp;* Statement는 DBMS에 설정된 OPEN CURSORS개수만큼 생성 가능.<br>&nbsp;* OPEN CURSORS란 하나의 커넥션(세션)에서 수행할 수 있는 Statement 개수<br>&nbsp;* Statement가 OPEN CURSORS보다 많으면 "Open Cursors exceed"라는 예외 발생.<br>&nbsp;* 그러므로 Statement를 다 사용한 뒤에 필히 닫아주어야 한다.<br><br><div class="h2">Statement for Select : stmt.executeQuery(query)</div><br><blockquote class="src">Statement&nbsp;stmt&nbsp;=&nbsp;conn.createStatement(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ResultSet.TYPE_SCROLL_INSENSITIVE,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ResultSet.CUSOR_READ_ONLY);<br>String&nbsp;query&nbsp;=&nbsp;"SELECT&nbsp;...";<br>ResultSet&nbsp;rs&nbsp;=&nbsp;stmt.executeQuery(query);<br>&nbsp;...<br>stmt.close();<br></blockquote><br><br><div class="h2">Statement for DML(UPDATE, DELETE, INSERT) : stmt.executeUpdate(query)</div><br><blockquote class="src">Statement&nbsp;stmt&nbsp;=&nbsp;conn.createStatement();<br>int&nbsp;countRow&nbsp;=&nbsp;stmt.executeUpdate("UPDATE&nbsp;book&nbsp;SET&nbsp;...");<br>//&nbsp;countRow는&nbsp;DML이&nbsp;적용된&nbsp;컬럼&nbsp;수를&nbsp;의미한다.<br>stmt.close();<br></blockquote><br><br><div class="h2">Statement for All(SELECT and DML) : stmt.execute(query)</div><br><blockquote class="src">Statement&nbsp;stmt&nbsp;=&nbsp;conn.createStatement();<br>boolean&nbsp;returnVal&nbsp;=&nbsp;stmt.execute("이런&nbsp;저런&nbsp;문장...");<br>//&nbsp;returnVal&nbsp;==&nbsp;true&nbsp;:&nbsp;SELECT문이&nbsp;실행됐음.<br>//&nbsp;returnVal&nbsp;==&nbsp;false&nbsp;:&nbsp;DML(UPDATE,&nbsp;DELETE,&nbsp;INSERT)<br>if&nbsp;(returnVal)&nbsp;==&nbsp;true)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;ResultSet&nbsp;rs&nbsp;=&nbsp;stmt.getResultSet();<br>&nbsp;&nbsp;&nbsp;&nbsp;...<br>}&nbsp;else&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;updateCount&nbsp;=&nbsp;stmt.getUpdateCount();<br>&nbsp;&nbsp;&nbsp;&nbsp;...<br>}<br><br>stmt.close();<br></blockquote><br><br><div class="h2">PreparedStatement</div><br>DBMS는 가장 최근에 수행된 SQL문장을 저장하고 있다가, 똑같은 SQL이 반복하여 들어올 경우에 별다른 수행계획없이 이전의 수행계획으로 SQL를 실행한다.<br>이때 속도가 빨라지게 된다.<br>PreparedStatement는 이러한 DBMS기능을 통하여 반복적인 SQL실행에서 사용되어 어플리케이션의 성능을 향상시킨다.<br><blockquote class="src">String&nbsp;sql&nbsp;=&nbsp;"SELECT&nbsp;a,&nbsp;b,&nbsp;c&nbsp;where&nbsp;a&nbsp;=&nbsp;?&nbsp;and&nbsp;b&nbsp;<=&nbsp;?";<br>PreparedStatement&nbsp;pstmt&nbsp;=&nbsp;conn.prepareStatement(sql);<br>pstmt.setString(1,&nbsp;"string");<br>pstmt.setInt(2,&nbsp;300);<br>...<br>ResultSet&nbsp;rs&nbsp;=&nbsp;pstmt.executeQuery();<br>...<br>pstmt.close();<br>conn.close();<br></blockquote><br>&nbsp;# ? 부분에 적합한 데이터형 Setter(setString(), setInt(),...)를 이용해 값을 끼워넣고 SQL을 실행한다.<br>&nbsp;# 특정 데이타에 Null 값을 세팅하고자 한다면, pstmt.setNull(3, java.sql.Type.VARCHAR);<br><br><div class="h2">Stored Procedure : DBMS에 미리 저장된 SQL명령 집합</div><br><blockquote class="src">DatabaseMetaData&nbsp;dmd&nbsp;=&nbsp;conn.getMetaData();<br>if&nbsp;(dmd.supportsStoredProcedure())&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;스토어드&nbsp;프로시져&nbsp;지원한다.<br>}&nbsp;else&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;스토어드&nbsp;프로시져&nbsp;지원&nbsp;안&nbsp;한다.<br>}<br></blockquote><br>스토어드 프로시저는 성능을 향상시킬수 있고, 보안성이 높으나, 코딩 규칙이 제대로 규정되지 않고 문서화가 안돼 있으면 유지보수성이 떨어지게 된다.<br><br><div class="h2">CallableStatement : DBMS의 Stored Procedure호출에 사용된다</div><br><blockquote class="src">CallableStatement&nbsp;cstmt&nbsp;=&nbsp;conn.prepareCall("{CALL&nbsp;functionname(?,?,?)}");<br>cstmt.setString(1,&nbsp;"아범노트북");<br>cstmt.setInt(2,&nbsp;1800000);<br>cstmt.setNull(3,&nbsp;java.sql.Type.VARCHAR);<br>cstmt.execute();<br></blockquote><br>CallableStatement도 execute()의 리턴값이 true이면 ResultSet이 있는것이고, false이면 DML을 실행하여 ResultSet이 없는 것이다.<br>스토어드 프로시져의 리턴값은 execute()하기전에 미리 리턴받을 값의 데이터형을 지정해 줘야 한다.<br><br><blockquote class="src">cstmt.registerOutParameter(1,&nbsp;Types.VARCHAR);<br>cstmt.registerOutParameter(2,&nbsp;Types.INTEGER);<br><br>&nbsp;...&nbsp;execute()&nbsp;후에&nbsp;리턴값&nbsp;얻기&nbsp;...<br><br>String&nbsp;s&nbsp;=&nbsp;cstmt.getString(1);<br>int&nbsp;i&nbsp;=&nbsp;cstmt.getInt(2);<br></blockquote><br>등과 같은 방식으로 얻는다.<br>CallableStatement 또한 Statement와 PreparedStatement처럼 execute(), executeQuery(), executeUpdate() 메소드를 호출할 수 있다.<br><br><div class="h2">ResultSet : SELECT의 결과를 저장하는 객체</div><br># ResultSet Type : 결과값 집합의 검색 방향에 대한 기능 정의<br>&nbsp;&nbsp;* TYPE_FORWARD_ONLY : 기본값. 아래 방향으로만 진행.<br>&nbsp;&nbsp;* TYPE_SCROLL_INSENSITIVE : 위 아래로 진행. 다른 동작에 의해 값이 바뀌었을 경우 바뀐 값 인식 안함.<br>&nbsp;&nbsp;* TYPE_SCROLL_SENSITIVE : 위 아래로 진행. 다른 동작에 의해 값이 바뀌었을 경우 바뀐 값 인식.<br><br># 병행성 : ResultSet 내의 결과값 집합에 대한 Update와 같은 조작이 가능한가?<br>&nbsp;&nbsp;* CONCUR_READ_ONLY : 기본값. 읽기만 가능.<br>&nbsp;&nbsp;* CONCUR_UPDATABLE : 값 수정 가능.<br><br># 유지성 : ResultSet 객체를 계속 유지할 것인가?<br>&nbsp;&nbsp;* HOLD_CURSORS_OVER_COMMIT : 커밋후에도 ResultSet 객체를 유지한다.<br>&nbsp;&nbsp;* CLOSE_CURSORS_AT_COMMIT : 커밋후에는 ResultSet 객체를 닫는다. 성능향상.<br><br><strong>Connection.createStatement()</strong> 메소드를 통해 지정한다.<br><br><div class="h3">DBMS가 지원하는 ResultSet 형태 정보 알아내기</div><br><blockquote class="src">DatabaseMetaData dbmd = con.getMetaData();<br></blockquote><br>&nbsp;* String dbmd.getDatabaseProductName() : 데이타베이스 제품 이름<br>&nbsp;* boolean dbmd.supportsResultSetType() : ResultSet Type 지원 여부<br>&nbsp;* boolean dbmd.supportsResultSetConcurrency() : 병행성 지원 여부<br>&nbsp;* int dbmd.getResultSetHoldability() : JDBC 3.0. 유지성 지원 여부<br><br><div class="h3">Cursor</div><br>&nbsp;* ResultSet 데이타의 각 행을 가리킨다.<br>&nbsp;* 최초 커서의 위치는 '''Before the first row'''이다.<br>&nbsp;* Cursor가 가리키는 위치를 이동하면서 각 행의 값을 조회하고 조작할 수 있다.<br><br>&nbsp;* <strong>next()</strong> boolean : 가장 많이 쓰임. 아래 방향으로 한 행씩 이동. 더이상 행이 존재하지 않을 때(After the last row)는 false. TYPE_FORWARD_ONLY 일 경우에는 next() 메소드만 정상적으로 수행된다.<br>&nbsp;* <strong>previous()</strong> boolean : 위 방향으로 이동. 더이상 위에 행이 없을 때(Before the first row)는 false.<br>&nbsp;* <strong>last()</strong> : boolean :마지막 행. false이면 현재 ResultSet에 아무 값도 없다는 뜻.<br>&nbsp;* <strong>first()</strong> void : 첫번째 행. false이면 현재 ResultSet에 아무 값도 없다는 뜻.<br>&nbsp;* <strong>beforeFirst()</strong> void : Before the first row로 이동<br>&nbsp;* <strong>afterLast()</strong> void : After the last row로 이동<br>&nbsp;* <strong>relative(int i)</strong> boolean : 현재 위치에서 i 만큼 이동. i가 음수이면 위로, 양수이면 아래로.<br>&nbsp;* <strong>absolute(int i)</strong> boolean : 양수일 경우에는 Before the first row를 기준으로, 음수일 경우에는 After the first row를 기준으로 하여 지정된 행으로 이동. 각 행은 1 혹은 -1 부터 시작한다.<br><br><div class="h3">값 얻기</div><br>&nbsp;# <strong>rs.getXXX(1번부터시작하는컬럼순서)</strong> 혹은 <strong>rs.getXXX("컬럼이름")</strong>을 이용해 값을 가져온다.<br>&nbsp;# 전형적인 ResultSet 사용 패턴<br><blockquote class="src">while&nbsp;(rs.next())&nbsp;{ &nbsp;&nbsp;String&nbsp;bookname&nbsp;=&nbsp;rs.getString(1);<br>&nbsp;&nbsp;int&nbsp;bookPrice&nbsp;=&nbsp;rs.getInt(2);<br>&nbsp;&nbsp;System.out.println("책&nbsp;이름&nbsp;:&nbsp;"&nbsp;+&nbsp;bookname&nbsp;+&nbsp;",&nbsp;값&nbsp;:&nbsp;"&nbsp;+&nbsp;bookPrice);<br>}<br></blockquote><br><br><div class="h3">ResultSetMetaData</div><br># 쿼리 결과로 얻은 ResultSet 객체로 부터 각 컬럼들에 대한 정보를 얻을 수 있다.<br><blockquote class="src">ResultSetMetaData rsmd = rs.getMetaData();<br></blockquote><br># java.sql.ResultSetMetaData API Doc 참조<br><br><div class="h3">ResultSet에서 행 삭제</div><br>&nbsp;* ResultSet이 CONCUR_UPDATABLE 속성일 경우에만 가능하다.<br>&nbsp;* 삭제할 행으로 이동한 뒤에<br><blockquote class="src">&nbsp;&nbsp;&nbsp;&nbsp;rs.deleteRow();<br></blockquote><br>&nbsp;* rs.rowDeleted() : 삭제된 행인가?<br>&nbsp;* DatabaseMetaData.othersDeletesAreVisible(int ResultSetType) : 다른 ResultSet에서 삭제된 행을 인식할 수 있는가?<br><br><div class="h3">ResultSet에서 새로운 행 삽입</div><br>&nbsp;* ResultSet이 CONCUR_UPDATABLE 속성일 경우에만 가능하다.<br>&nbsp;* 행을 삽입할 가상 위치로 이동<br><blockquote class="src">rs.moveToInsertRow();<br></blockquote><br>&nbsp;* 삽입할 값 설정. 컬럼 번호 이용.<br><blockquote class="src">rs.updateString(1, "한솔");<br>rs.updateInt(2, 50000000);<br></blockquote><br>&nbsp;* 삽입 완료하고 기존 위치로 이동<br><blockquote class="src">rs.insertRow(); // 실제 삽입<br>rs.moveToCurrentRow(); // 기존 위치로 이동<br></blockquote><br>&nbsp;* <strong>rs.insertRow()</strong>를 실행하기 전에 <strong>rs.moveToCurrentRow()</strong>를 실행하면 모든 설정값을 잃고 삽입은 실패하게 된다.<br>&nbsp;* 만약 NULL 일 수 없는 컬럼을 빼먹고 설정하지 않으면 Exception이 발생한다. NULL일 수 있는 값은 생략하면 NULL로 설정된다.<br>&nbsp;* Default값이 있을 경우에는 생략하면 기본값이 들어가게 된다.<br><br><div class="h3">ResultSet에서 컬럼 수정</div><br>&nbsp;* ResultSet이 CONCUR_UPDATABLE 속성일 경우에만 가능하다.<br>&nbsp;* 수정할 컬럼이 있는 행으로 이동한다.<br>&nbsp;* 값을 수정하고 적용한다.<br><blockquote class="src">// 수정<br>rs.updateInt("컬럼이름", 1700000);<br>// 수정된 값 실제로 적용.<br>rs.updateRow();<br></blockquote><br>&nbsp;* rs.updateRow()를 하기전에 행을 이동하면 수정사항이 반영되지 않는다.<br>&nbsp;* TYPE_SCROLL_SENSITIVE가 아니라면 수정 사항을 현재 ResultSet에서 확인할 수 없다. 그러나 실제 DBMS에는 반영되어 있다.<br><br><div class="h2">Batch 업데이트</div><br>&nbsp;# 여러 SQL문을 일괄 실행한다.<br>&nbsp;# AutoCommit을 끄고, 일괄 실행할 SQL문을 추가하고, 성공하면 Commit하고 실패하면 RollBack한다.<br><br><div class="h3">Statement 배치 실행하기</div><br><blockquote class="src">try&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;con.setAutoCommit(false);<br>&nbsp;&nbsp;&nbsp;&nbsp;Statement&nbsp;stmt&nbsp;=&nbsp;con.createStatement();<br>&nbsp;&nbsp;&nbsp;&nbsp;stmt.addBatch("SQL&nbsp;문1");<br>&nbsp;&nbsp;&nbsp;&nbsp;stmt.addBatch("SQL&nbsp;문2");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;....<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;각&nbsp;업데이트가&nbsp;몇개의&nbsp;행에&nbsp;영향을&nbsp;끼쳤는가?<br>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;[]&nbsp;uprowcount&nbsp;=&nbsp;stmt.executeBatch();&nbsp;//&nbsp;SQL문장&nbsp;실행<br>&nbsp;&nbsp;&nbsp;&nbsp;con.commit();<br>}&nbsp;catch&nbsp;(BatchUpdateException&nbsp;be)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;예외&nbsp;발성&nbsp;전까지&nbsp;성공적으로&nbsp;수행된&nbsp;문장&nbsp;개수<br>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;updatedCount&nbsp;=&nbsp;be.getUpdateCounts().length;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;각&nbsp;업데이트가&nbsp;몇개의&nbsp;행에&nbsp;영향을&nbsp;끼쳤는가?<br>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;[]&nbsp;updateCount&nbsp;=&nbsp;be.getUpdateCounts();<br>}<br></blockquote><br>&nbsp;* statement.addBatch("SQL문장") : 배치 실행할 SQL 문장 추가<br>&nbsp;* statement.executeBatch() : 배치 실행<br>&nbsp;* batchUpdateException.getUpdateCounts() : 배치 실행된 각각의 업데이트가 영향을 끼친 행의 개수에 대한 int 배열<br>&nbsp;* <strong>배치 작업 내의 작업 리스트는 Update Count를 리턴하는 SQL문이어야만 한다. SELECT같은 ResultSet을 반환하는 문장은 사용할 수 없다.</strong><br><br><div class="h3">PreparedStatement 배치 실행하기</div><br>&nbsp;* Statement와 거의 동일하다.<br><blockquote class="src">PreparedStatement&nbsp;pstmt&nbsp;=&nbsp;con.prepareStatement("....");<br><br>pstmt.setString(1,"ABC");<br>pstmt.setInt(2,2000);<br>pstmt.addBatch();&nbsp;//&nbsp;지금까지&nbsp;입력된&nbsp;데이터를&nbsp;배치&nbsp;작업에&nbsp;추가<br><br>pstmt.setString(1,&nbsp;"DEF");<br>pstmt.setInt(2,&nbsp;3000);<br>pstmt.addBatch();<br><br>&nbsp;&nbsp;....<br><br>int&nbsp;[]&nbsp;uprowcount&nbsp;=&nbsp;pstmt.executeBatch();<br></blockquote><br><br><div class="h3">CallableStatement 배치 실행하기</div><br>&nbsp;* PreparedStatement와 동일하지만, OUT 파라미터나 INOUT 파라미터 작업을 한다면 배치 작업을 할 수 없다.<br><br><div class="h2">트랜잭션(Transaction)</div><br>&nbsp;* <strong>Connection.setAutoCommit(true/false)</strong> : 자동으로 커밋할 것인가 여부. 기본값 true.<br>&nbsp;* <strong>Connection.commit()</strong> : 커밋<br>&nbsp;* <strong>Connection.rollback()</strong> : 롤백<br><br><div class="h3">트랜잭션 고립 레벨</div><br>&nbsp;* 트랜잭션에서 병행 작업시 발생하는 문제점<br>&nbsp;&nbsp;o dirty reads : 다른 트랜잭션에서 커밋되지 않은 변경내용을 볼 수 있다.<br>&nbsp;&nbsp;o nonrepeatable reads : 최초에 읽기 작업 후, 다른 트랜잭션이 데이터를 변경 시키고, 그 다음 읽기 작업이 변경된 사항을 읽어들여 최초의 읽기와 두 번째 읽기 작업의 결과 불일치.<br>&nbsp;&nbsp;o phantom reads : nonrepeatable reads에 where 조건 추가.<br>&nbsp;* 고립 레벨 종류<br>&nbsp;&nbsp;o TRANSACTION_NONE : 트랜잭션 지원 안함.<br>&nbsp;&nbsp;o TRANSACTION_READ_UNCOMMITTED : 커밋되지 않은 데이터도 볼 수 있음.<br>&nbsp;&nbsp;o TRANSACTION_READ_COMMITTED : 커밋된 데이터만 볼 수 있음.<br>&nbsp;&nbsp;o TRANSACTION_REPEATABLE_READ : dirty reads와 nonrepeatable reads 방지. phantom reads는 방지 못함.<br>&nbsp;&nbsp;o TRANSACTION_SERIALIZABLE : dirty/nonrepeatable/phantom reads 모두 방지.<br>&nbsp;* Connection.setTransactionIsolation(int level) : 고립 레벨 지정. 커넥션을 닫거나 재지정할 때 까지 유지.<br>&nbsp;* DatabaseMetaData.surpportsTransactionIsolationLevel(int level) : 고립 레벨 지원 여부 확인.<br><br><div class="h3">SavePoints : JDBC 3.0</div><br>&nbsp;* SavePoints 는 트랜잭션 작업 사이에 SavePoint를 정의해 두고 지정된 SavePoint로부터의 작업들을 커밋이나 롤백할 수 있도록 한다.<br>&nbsp;* DatabaseMetaData.supportsSavePoints() : SavePoints 지원 여부.<br>&nbsp;* Savepoint sp1 = con.setSavepoint("SP1") : SavePoint 지정.<br>&nbsp;* con.rollback(sp1) : 지정된 SavePoint까지 롤백.<br><br><div class="h2">JDBC 3.0 새로운 데이타 타입</div><br>&nbsp;* SQL99의 새로운 데이터 타입들<br>&nbsp;* Blob/Clob 읽기<br><blockquote class="src">Blob b1 = rs.getBlob(3);<br>Clob c1 = rs.getClob(4);<br></blockquote><br><br>&nbsp;* Blob/Clob 저장하기<br><blockquote class="src">PreparedStatement pstmt = conn.preparedStatement("INSERT INTO PRODUCT (image, etc) VALUES (?,?));<br>pstmt.setBlob(1, blobimage);<br>pstmt.setClob(2, clobdescription);<br></blockquote><br>&nbsp;* Array<br><blockquote class="src">java.sql.Array ar = rs.getArray("arraycolumn");<br>...<br>pstmt.setArray(1, ar);<br><br>// 업데이트<br>rs.updateArray("arrayColumn", ar);<br></blockquote><br><br>&nbsp;* Ref : 레퍼런스. 실제 데이터에 대한 포인터 역할.<br><blockquote class="src">Ref ref = rs.getRedf("refcolumn");<br><br>Address addr = (Address)ref.getObject();<br></blockquote><br><br>&nbsp;* Datalink : 외부 데이터에 대한 참조 링크<br><blockquote class="src">java.net.URL addurl = rs.getURL("urlColumn");<br></blockquote><br><br><div class="h2">사용자 정의 데이터 타입</div><br>&nbsp;* 데이터베이스에서 사용자 정의 타입을 만들고, 그것을 자바에서 SQLData 인터페이스를 구현한 자바 클래스와 매핑할 수 있다.<br>&nbsp;* SQLData 구현<br><blockquote class="src">import&nbsp;java.sql.*;<br><br>public&nbsp;class&nbsp;ProductType&nbsp;implements&nbsp;SQLData&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;p_num;<br>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;p_name;<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;sqlType&nbsp;=&nbsp;"product_type";<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;getSQLTypeName()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;sqlType;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;readSQL(SQLInput&nbsp;stream,&nbsp;String&nbsp;type)&nbsp;throws&nbsp;SQLException&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.sqlType&nbsp;=&nbsp;type;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p_num&nbsp;=&nbsp;stream.readInt();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p_name&nbsp;=&nbsp;stream.readString();<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;writeSQL(SQLOutput&nbsp;stream)&nbsp;throws&nbsp;SQLException&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stream.writeInt(p_num);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stream.writeString(p_name);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></blockquote><br>&nbsp;* 구현을 Connection의 TypeMap에 등록<br><blockquote class="src">java.util.Map typeMap = conn.getTypeMap();<br>map.put("SchemaName.PRODUCT_TYPE", Class.forName("ProductType"));<br></blockquote><br>&nbsp;* 읽기<br><blockquote class="src">ProductType pt = (ProductType)rs.getObject(1);<br></blockquote><br>&nbsp;* Connection에 새로운 타입 맵 추가<br><blockquote class="src">Hashtable newMap = new Hashtable();<br> ....<br>conn.setTypeMap(newMap);<br></blockquote><br>&nbsp;* 수정<br><blockquote class="src">//먼저 ResultSet에서 클래스 인스턴스를 얻고, 수정 사항을 수정한 뒤에<br>ProductType upproduct = (ProductType)rs.getObject(1);<br> ...<br>pstmt.setObject(1, upproduct);<br></blockquote><br></div>
                        <div class="post-footer">
                            <button class="btn" onclick="button_click();">목록</button>
                        </div>
                    </div>
                </article>
            </main>
        </section>

        <script src="https://code.jquery.com/jquery-3.5.1.js"></script>

        <script>
            function button_click() {
                if(history.length > 1) {
                    history.back();
                } else {
                    document.location.href = "../../블로그포스트목록.html";
                }
            }
        </script>
    </body>
</html>
