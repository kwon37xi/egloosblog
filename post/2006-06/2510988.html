<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="../../css/result.css">

        <title>J2SE 5 뭐가 달라졌나?</title>
    </head>
    <body>
        <section id="wrap">
            <header>
                <h1 class="logo-title">
                    <span class="main"><img src="../../images/logo_egloos.png" width="105" height="34" alt="이글루스"></span>
                </h1>
                <div class="user-info">
                    <strong class="name">권남</strong> 님 (<strong class="name">kwon37xi</strong>)
                </div>
            </header>
            <main>
                <article class="post-wrap">
                    <!-- 게시물 정보 : 날짜 -->
                    <div class="post-info">
                        <span class="time">2006-06-22 22:48:39</span>
                    </div>
                    <!-- 게시물 제목 -->
                    <h2 class="post-title">J2SE 5 뭐가 달라졌나?</h2>
                    <!-- 게시물 본문 -->
                    <div class="post-body">
                        <div class="content">이 글은 원래 <a title="" href="http://kangcom.com/common/bookinfo/bookinfo.asp?sku=200305090002">Effective Java</a>의 저자인 Joshua Bloch 이 쓴 시에 부연 설명을 붙인 것으로, Java 5 Tiger가 기존 Java 1.4 와 달라진 점을 시로 쓴 것이다.<br><a title="" href="http://kr.blog.yahoo.com/kwon37xi/196553.html">Yahoo Blog</a>를 사용할 때 번역하다 만 것인데, 마저 번역한다.<br><br>원래 영어를 잘 못하는데다 시이기 때문에 번역이 매우 난해한데, 사실 의미 파악이 안돼서, 직접 코드를 실행해보고 이해한 내용을 내맘대로 써버린 부분도 많다.<br>그리고 원문은 베타 버전일 때 나온 것이기 때문에 정식 버전이 나온 현재와는 다른 점이 있다. 그에 관해서는 직접 코드를 테스트하여 달라진 점을 기록하였고, 몇몇 원문에 없는 내용도 추가되었다.<br><br><a title="" href="http://java.sun.com/j2se/1.5.0/docs/relnotes/features.html">http://java.sun.com/j2se/1.5.0/docs/relnotes/features.html</a>에서 더 자세하게 Java 5의 달라진 점을 알아볼 수 있으므로 참고한다.<br><br>추가 : <a title="" href="http://www.suntraining.co.kr/jsp/certification/study/SCJP5.pdf">http://www.suntraining.co.kr/jsp/certification/study/SCJP5.pdf</a> 에도 Java 5에 관한 사항이 잘 정리되어 있다.<br><br>추가 : <a title="" href="http://www.dev2dev.co.kr/pub/a/2005/12/java_5_features.jsp">Dev2Dev의 Java 5의 새로운 기능</a><br><br>tags : java 5 1.5 tiger j2se what's new 자바 타이거 달라진점<div class="h1">J2SE 5 뭐가 달라졌나?</div><br><center>Based on Joshua Bloch's on-line talk</center><br><br>원문 : <a title="" href="http://www.javacamp.org/scjp/whatsnew15.html">http://www.javacamp.org/scjp/whatsnew15.html</a><br>번역 : 손권남(kwon37xi@yahoo.co.kr, <a href="http://kwon37xi.egloos.com">http://kwon37xi.egloos.com</a>)<br><br>1. J2SE 5.0(타이거-호랑이) 베타버전이 2004년 초 공개됐다. 이 릴리즈는 품질, 모니터링과 관리 편의, 성능 향상과 확장성 그리고 개발과 데스크탑 용도 사용 편의라는 몇몇 핵심 주제에 포커스를 맞추고 있다.<br><br>2. Joshua Bloch 가 쓴 타이거에 관한 시가 아래에 인용되어 있다.<br><br>3. 제너릭(Generics) - 컴파일 할 때 컬렉션에 자료형을 안전하게 사용할 수 있도록 보장해주며, 짜증나는 캐스팅을 없애준다.<br><br>시 인용:<br><blockquote class="quote">가장 짜증나는 캐스팅에게<br>우리는 드디어 작별을 고하네<br>제너릭의 불타오르는 창끝에<br>캐스팅은 사라져가네.<br></blockquote><br>String 객체를 위해 java.util.List를 사용해서 값을 가져올 때마다 String 으로 캐스팅을 해야했다.<br><br><blockquote class="src">List&nbsp;names&nbsp;=&nbsp;new&nbsp;ArrayList();<br>...<br>String&nbsp;name&nbsp;=&nbsp;(String)names.get(idx);<br></blockquote><br><br>제너릭을 이용하면, List&lt;String&gt;으로 선언하여 컴파일러가 대신 형을 검사하게 한다. 자료형을 안전하게 사용할 수 있고, 리스트에서 값을 가져올 때 캐스팅도 불필요 하다. 그러므로 위 코드는 다음과 같이 쓸 수 있다.<br><br><blockquote class="src">List&lt;String&gt;&nbsp;names&nbsp;=&nbsp;new&nbsp;ArrayList&lt;String&gt;();<br>...<br>String&nbsp;name&nbsp;=&nbsp;names.get(idx);<br></blockquote><br>주의: <strong>J2SE 컴파일러는 자동으로 자료형을 검사해 줄것이다. ClassCastException은 발생하지 않을 것이고, 컬렉션의 요소가 필요할 때 캐스팅할 필요도 없다.</strong><br><br>예제 하나 더 : 4문자 단어 없애기<br><br>현재의 코드:<br><blockquote class="src">static&nbsp;void&nbsp;expurgate(Collection&nbsp;c)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(Iterator&nbsp;i&nbsp;=&nbsp;c.iterator();&nbsp;i.hasNext();&nbsp;)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;s&nbsp;=&nbsp;(String)&nbsp;i.next();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(s.length()&nbsp;==&nbsp;4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i.remove();<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></blockquote><br>제너릭을 이용한 코드:<br><blockquote class="src">static&nbsp;void&nbsp;expurgate(Collection&lt;String&gt;&nbsp;c)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(Iterator&lt;String&gt;&nbsp;i&nbsp;=&nbsp;c.iterator();&nbsp;i.hasNext();&nbsp;)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(i.next().length()&nbsp;==&nbsp;4)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i.remove();<br>}<br></blockquote><br>자바의 제너릭은 형을 철저하게 검사하여, 오직 지정된 형 파라미터의 메소드만을 호출 할 수 있다.<br>제너릭 메소드 선언의 예를 보이면:<br><blockquote class="src">&nbsp;&nbsp;&nbsp;&nbsp;....<br>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;f(T&nbsp;t)&nbsp;{&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t.whatever();&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br></blockquote><br>그리고 이 메소드의 형 파라미터를 Foo의 서브클래스나 서브인터페이스로 지정했다.<br>만약 Foo가 whtaever() 메소드를 가지고 있다면, whtever() 메소드를 사용할 수 있고, 정적으로 형 검사를 하게 되며 안전한 형이 된다.<br><br>형 파라미터 여러개 주기:<br><blockquote class="src">&lt;T&nbsp;extends&nbsp;Interface1&nbsp;&amp;&nbsp;Interface2&gt;<br></blockquote><br>서로 다른 형 파라미터를 지정할 때 쉼표(,) 대신에 &amp; 가 쓰였음을 주의하라.<br><br>4. 발전된 for 반복문 - 짜증나고 오류나기 쉬운 이터레이터를 없애준다.<br><br>시 인용:<br><blockquote class="quote">이터레이터가 쓰일 때<br>그들은 때때로 올가미 처럼 우리를 옥죄었네<br>발전된 for 문이 한줄기 서광이되어<br>이터레이터를 궁지에 빠뜨렸네.<br></blockquote><br>발전된 for 반복문("foreach"로 알려진)이 이터레이터나 인덱싱 변수 없이 컬렉션과 배열을 순회 할 수 있게 해준다.<br><br>현재의 코드:<br><blockquote class="src">void&nbsp;cancelAll(Collection&nbsp;c)&nbsp;{&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(Iterator&nbsp;i&nbsp;=&nbsp;c.iterator();&nbsp;i.hasNext();&nbsp;)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TimerTask&nbsp;tt&nbsp;=&nbsp;(TimerTask)&nbsp;i.next();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tt.cancel();<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></blockquote><br>J2SE 5.0의 코드:<br><blockquote class="src">void&nbsp;cancelAll(Collection&nbsp;c)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(Object&nbsp;o&nbsp;:&nbsp;c)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((TimerTask)o).close();<br>}<br></blockquote><br>콜론( : )은 "in."이라고 읽는다.<br><br>혹은 두가지 새로운 기능을 이용해:<br><blockquote class="src">void&nbsp;cancelAll(Collection&lt;TimerTask&gt;&nbsp;c)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(TimerTask&nbsp;task&nbsp;:&nbsp;c)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;task.cancel();<br>}<br></blockquote><br><br>5. 오토박싱(Autoboxing)/언박싱(Unboxing) - 원시 형(int 같은)과 래퍼 객체(Integer 같은)간의 짜증나는 수동 변환을 없애준다.<br>예를 들면,<br><br>시 인용:<br><blockquote class="quote">컬렉션에서 int 를 빼낼 때 마다<br>래퍼 클래스는 우릴 슬프게 만들었네.<br>호랑이가 나타나면 우리는 눈물을 멈추리<br>우리는 이삭이 패이면 그대로 오토박싱 할 것이다.<br></blockquote><br><br>J2SE 5.0 코드:<br><blockquote class="src">public&nbsp;class&nbsp;Freq&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[])&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Map&lt;String,&nbsp;Integer&gt;&nbsp;m&nbsp;=&nbsp;new&nbsp;TreeMap&lt;String,&nbsp;Integer&gt;();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(String&nbsp;word&nbsp;:&nbsp;args)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.put(word,&nbsp;m.get(word)&nbsp;+&nbsp;1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(m);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></blockquote><br><br>현재의 코드:<br><blockquote class="src">public&nbsp;class&nbsp;Freq&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;final&nbsp;Integer&nbsp;ONE&nbsp;=&nbsp;new&nbsp;Integer(1);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String&nbsp;args[])&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Map&nbsp;m&nbsp;=&nbsp;new&nbsp;TreeMap();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i=0;&nbsp;i&lt;args.length;&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer&nbsp;freq&nbsp;=&nbsp;(Integer)&nbsp;m.get(args[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m.put(args[i],&nbsp;(freq==null&nbsp;?&nbsp;ONE&nbsp;:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;Integer(freq.intValue()&nbsp;+&nbsp;1)));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(m);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></blockquote><br>&nbsp;* Boxing : 객체지향 언어에서 원시 형(primitive type, int, long 등)을 래퍼 객체(Integer, Long 등)에 넣어서 객체처럼 사용할 수 있게 하는 것을 의미한다. Java의 경우 원시형은 객체가 아니므로 객체만 저장 가능한 List 등에 원시형을 넣을 때 래퍼 객체에 원시형을 넣고(Boxing 하고) 그 후에 List에 넣어야 한다. Java 5 이전에는 프로그래머가 직접 Boxing을 해야했다.<br>&nbsp;* Autoboxing : Autoboxing은 부가적인 코드 없이 원시형을 자동으로 객체로 취급하는 것을 의미한다.<br>&nbsp;* Unboxing : Unboxing은 부가적인 코드 없이 래퍼 객체를 자동으로 원시형으로 취급하는 것을 의미한다.<br>&nbsp;&nbsp;&nbsp;from <a title="" href="http://en.wikipedia.org/wiki/Autoboxing">Wikipedia</a><br><br>6. 형이 안전한(Typesafe) enum - 이것은 말 많고 에러 나기 쉬운 점들이 없이 Typesafe Enum 의 잘 잘려진 장점들을 제공해 준다.<br><br>주의 : <strong>enum 은 Java 5에새 새로 생긴 키워드이므로, 옛날 자바 코드에서 enum을 형의 이름(변수/클래스/메소드 이름 등)으로 사용했다면, -source 1.5 를 사용하기 위해 그것들을 모두 수정해야 한다.</strong><br><br>시 인용:<br><blockquote class="quote">정수 enum 은 곧 사라지리<br>너무 오랫동안 우리를 괴롭혔던 적과 함께.<br>형이 안전한 enum의 강력한 힘은<br>우리의 적을 무력화 시키네.<br></blockquote><br><blockquote class="src">* Coin.java -------------------- <br>public&nbsp;enum&nbsp;Coin&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;penny(1),&nbsp;nickel(5),&nbsp;dime(10),&nbsp;quarter(25);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;Coin(int&nbsp;value)&nbsp;{&nbsp;this.value&nbsp;=&nbsp;value;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;int&nbsp;value;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;value()&nbsp;{&nbsp;return&nbsp;value;&nbsp;}<br>}<br><br>* CoinTest.java -------------------- <br>public&nbsp;class&nbsp;CoinTest&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(Coin&nbsp;c&nbsp;:&nbsp;Coin.values()) // 바뀐 부분<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(c&nbsp;+&nbsp;":&nbsp;&nbsp;&nbsp;"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;c.value()&nbsp;+"?&nbsp;"&nbsp;+&nbsp;color(c));<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;enum&nbsp;CoinColor&nbsp;{&nbsp;copper,&nbsp;nickel,&nbsp;silver&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;CoinColor&nbsp;color(Coin&nbsp;c)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch(c)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;penny:&nbsp;&nbsp;&nbsp;return&nbsp;CoinColor.copper;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;nickel:&nbsp;&nbsp;return&nbsp;CoinColor.nickel;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;dime:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;quarter:&nbsp;return&nbsp;CoinColor.silver;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:&nbsp;throw&nbsp;new&nbsp;AssertionError("Unknown&nbsp;coin:&nbsp;"&nbsp;+&nbsp;c);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></blockquote><br>상수 선언이 동전을 대표하는 숫자를 넘겨주면서 어떻게 생성자를 호출하는지 보라. 그리고 어떻게 private 필드에 public 접근자로 값을 저장하는지 보라. 색깔을 위한 또 다른 enum을 어떻게 생성했는지 보라. enum 상수를 어떻게 switch 구문에 사용하는지 보라. 이것은 당신이 enum 클래스에 "메소드를 추가"하고자 할 때 매우 유용하다. 하지만 어떤 이유로든 클래스를 수정할 수는 없다.<br><br>사실 새로운 enum은 다른 언어의 구조체(struct)에 불과하다. enum에 메소드와 필드를 추가하지 않는다면 그것은 형이 안전한 enum 상수와 같다. 만약 메소드와 필드를 추가하면, 완전한 객체가 된다.<br>&nbsp;* 추가<br>&nbsp;&nbsp;- Java 5의 enum 형에는 메소드와 필드를 추가할 수 있다. 다른 언어의 enum 형과 다른 점이다.<br>&nbsp;&nbsp;- 각 enum 타입은 static values() 메소드를 가지고 있다. 이 메소드는 enum의 모든 값을 배열로 리턴한다.<br>&nbsp;&nbsp;- 원문에서는 Coin.VALUES로 Coin의 상수 값들을 가져왔지만, 실제론 작동하지 않는다. values() 메소드를 사용해야 한다.<br>&nbsp;&nbsp;- 원문에서는 switch의 case 문에서 Coin.penny 와 같은 식으로 값을 지정했지만 실제로는 penny 로만 지정하게 바뀌었다. switch/case에서 case 문에 사용되는 enum 형에만 해당된다. 리턴값인 CoinColor.copper는 그대로이다.<br><br>7. Static import - Static import 는 Constant Interface 안티패턴의 단점을 피해, 클래스이름없이 정적 멤버를 사용할 수 있게 해준다.<br><br>예를 들면:<br><br>시 인용:<br><blockquote class="quote">그리고 상수 인터페이스로부터<br>우리는 더이상 불명예를 물려받지 않으리라.<br>static import를 통해<br>우리의 기쁨이 무한해 지리라.<br></blockquote><br><blockquote class="src">public&nbsp;interface&nbsp;Promotion&nbsp;{<br>&nbsp;&nbsp;public&nbsp;static&nbsp;final&nbsp;double&nbsp;MANAGER_RATE&nbsp;&nbsp;&nbsp;=&nbsp;0.59;<br>&nbsp;&nbsp;public&nbsp;static&nbsp;final&nbsp;double&nbsp;SUPERVISER_RATE&nbsp;&nbsp;&nbsp;=&nbsp;0.35;<br>}<br></blockquote><br>Promotion 인터페이스를 사용하려할 때, 지금까지는 인터페이스를 구현(implement)해야 했다. 하지만 J2SE 5.0 에서는 다음과 같이 import 해도 된다.<br><br><blockquote class="src">import&nbsp;static&nbsp;whatever.sub.Promotion.*;<br><br>class&nbsp;Test&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;extra_salary&nbsp;=&nbsp;MANAGER_RATE&nbsp;*&nbsp;current_salary;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></blockquote><br>주의: Promotion은 클래스이어도 된다. 상수 클래스 디자인에 유용하다.<br>주의: static 메소드도 같은 방식으로 사용할 수 있다.<br>주의: 원문에서는 "import static whatever.sub.Promotion"했지만 실제로는 <strong>"import static whatever.sub.Promotion.*"</strong>해야 한다.<br>주의: static import는 남용해서는 안된다. 남용하면 코드의 가독성을 떨어뜨린다. <strong>되도록 static import 할 때 멤버명까지 지정하는 것이 좋다. 멤버명은 상수 멤버나 public static 메소드명도 된다.</strong><br><br>8. Metadata(Annotation) - 어노테이션은 소스코드내에 작성된 어노테이션을 통해 자동으로 코드를 생성해 주어, 반복적인 공통 코드 작성을 피하게 해준다. 어노테이션은 프로그래머가 뭔가가 작동해야 한다고 말하는 그 지점에서 "선언적 프로그래밍"이 가능하게 만들고, 도구는 그 작업을 하는 코드를 생성해낸다.<br><br>시 인용:<br><blockquote class="quote">그리고 고귀하신 메타데이타(Annotation)에 대해서는<br>나중으로 찬양을 미뤄야겠다.<br>그의 쓰임이 너무도 다양하여<br>제대로 찬미하다간, 버스를 놓칠 판이다.<br></blockquote><br><blockquote class="src">public&nbsp;class&nbsp;Test&nbsp;{&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;@Somewhere&nbsp;public&nbsp;void&nbsp;someMethod()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></blockquote><br>@Somewhere 어노테이션에 의해 코드가 생성될 것이다.<br><br>이것은 "프로그램 어노테이션"이라고 불린다.<br><br>주의 : 메타데이타를 위해 새로운 키워드가 추가되지는 않았다. 대신 이미 쓰이는 기호를 다시 사용했다. 어노테이션 형을 정의하려면:<br><blockquote class="src">&nbsp;public&nbsp;@interface&nbsp;Foo&nbsp;{&nbsp;...&nbsp;}&nbsp;<br></blockquote><br>저기 "@interface"가 "어노테이션 형(annotation-type)" (눈치챘나요? a-t -&gt; at -&gt; @)이다.. 또한 이것은 javadoc 태그 처럼 보이기도 한다.<br><br>어노테이션 사용:<br><blockquote class="src">@Copyright("Acme&nbsp;Inc")&nbsp;public&nbsp;static&nbsp;final&nbsp;int&nbsp;baz(...)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;...<br>}<br></blockquote><br><br>9. Java 변수 인자들이 객체의 배열이다. 컴파일러는 인자 메소드에 전달된 목록에 기반하여 배열로 합친다.<br><blockquote class="src">public&nbsp;void&nbsp;aMethod(String...&nbsp;args)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;for(String&nbsp;s&nbsp;:&nbsp;args)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(s);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></blockquote><br>aMethod 는 다음과 같은 형태로 호출된다 :<br><br><blockquote class="src">aMethod("here","we","go");&nbsp;//3&nbsp;argument&nbsp;list<br>aMethod("to","be","or","not","to","be");&nbsp;//6&nbsp;argument&nbsp;list<br></blockquote><br>컴파일러는 인자 목록을 자동으로 다음과 같이 만든다 :<br><blockquote class="src">aMethod(new&nbsp;String[]&nbsp;{"here","we","go"});<br>aMethod(new&nbsp;String[]&nbsp;{"to","be","or","not","to","be"});<br></blockquote><br>참조 : 이 varargs 기능을 이용한 메소드들이 몇몇 추가 되었다. 다음을 참조해보라.<br>&nbsp;- <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/io/PrintWriter.html#printf(java.lang.String,%20java.lang.Object...)">java.io.PrintWriter.printf()</a><br>&nbsp;- <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Formatter.html#format(java.lang.String,%20java.lang.Object...)">java.util.Formatter.format()</a><br><br>10. 리플렉션 API가 enum, 제너릭, 어노테이션을 다룰 수 있도록 확장되었다.<br>11. J2SE 5.0은 바뀐 핵식 XML 플랫폼을 도입하고 있다. XML 1.1, SAX 2.0 그리고 DOM Level 3.<br>12. 32-bit 대행 문자지원이 조심스럽게 추가되어, 기존 Java "char"형은 여전히 16bit로 남아있다.<br>13. java.lang.StringBuilder가 추가되었다. 이것은 java.lang.StringBuffer의 비동기(unsynchronized)버전이다. StringBuffer가 동기화되어 있기 때문에 문자열 연결이 약간 느리다. 컴파일러는 StringBuilder를 문자열 합치기 연산에 사용할 것이고, 이로인해 몇몇 어플리케이션에서는 상당한 성능향상을 보일 것이다. (다시말해, <strong>쓰레드에 안전한 연산에서는 StringBuffer보다 StringBuilder를 사용하는 것이 좋다!</strong>)<br>14. XP 룩앤필과 리눅스 GTK 2.0 룩앤필이 추가되었다. 기본 룩앤필(메탈)도 개선되었다.<br>15. 프로그램 시작 속도가 빨라졌다.<br>16. X.class는 "Class" 형이다.<br>17. JTable과 기타 클래스의 기능을 사용하기가 쉬워졌다.<br>18. java.util.concurrent(병행 프로그래밍 API)같은 많은 새로운 API들이 추가되었다.<br>19. weak reference와 thread local 같은 모든 래퍼(wrapper) 클래스들은 제너릭을 사용할 수 있도록 개선되었다. List 같은 열거형 제너릭을 리턴하는 몇몇 API들도 마찬가지다.<br>20. Tuple 이라 불리우는 여러 리턴형을 다루는 방법이 더 미래의 Java 버전에 도입될 예정이다.<br>21. "const" 키워드가 J2SE 5.0이나 그 이후 버전에서 사라질 것이다. 대신 "final"을 사용하라.<br>22. java.util.Date는 그대로이다. 약간의 달라진점이라면, Comparable 대신 Comparable<Date>를 구현(implement)했다는 점이다. Date 클래스는 값이 변하는 문제를 앉고 있다. 언제 바뀔까? 나도 모르지 뭐.<br>23. J2SE 5.0에는 J++와 C#에 있는 delegates 기능이 포함되지 않았다.<br>24. J2SE 5.0에는 연산자 오버로딩 기능이 포함되지 않았다.<br>25. 더 많은 달라진 점들이 있을 것이다. 귀를 기울이고 있으라.<br><br>26. JVM GC/Memory/Thread 모니터링 기능.<br>다음의 옵션을 주어서 어플리케이션을 실행한 뒤에,<br><blockquote class="src">-Dcom.sun.management.jmxremote</blockquote><br>다음 명령으로 JCONSOLE을 실행해서 JVM을 모니터링할 수 있다.<br><blockquote class="src">$JAVA_HOME/bin/jconsole</blockquote><br><br><div class="h2">Joshua Bloch의 시</div><br><blockquote class="quote">Tiger, Tiger Burning Bright<br>Like a geek who works all night<br>What new-fangled bit or byte<br>Could ease the hacker's weary plight?<br><br>To the most despised cast<br>We'll bid a fond farewell at last<br>With generics' burning spear<br>The need for cast will disappear<br><br>While Iterators have their uses<br>They sometimes strangle us like nooses<br>With enhanced-for's deadly ray<br>Iterator's kept at bay<br><br>When from collections ints are drawn<br>Wrapper classes make us mourn<br>When Tiger comes, we'll shed no tears<br>We'll autobox them in the ears<br><br>The int-enum will soon be gone<br>like a foe we've known too long<br>With typesafe-enum's mighty power<br>Our foe will bother us no more<br><br>And from the constant interface<br>we shall inherit no disgrace<br>With static import at our side,<br>our joy will be unqualified<br><br>And as for noble metadata<br>I'll have to sing its praises later<br>Its uses are so numerous<br>To give their due, I'd miss the bus<br></blockquote><br></div>
                        <div class="post-footer">
                            <button class="btn" onclick="button_click();">목록</button>
                        </div>
                    </div>
                </article>
            </main>
        </section>

        <script src="https://code.jquery.com/jquery-3.5.1.js"></script>

        <script>
            function button_click() {
                if(history.length > 1) {
                    history.back();
                } else {
                    document.location.href = "../../블로그포스트목록.html";
                }
            }
        </script>
    </body>
</html>
