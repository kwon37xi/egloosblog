<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="../../css/result.css">

        <title>동적 Native SQL 생성 어떻게 할까 - 순수 Java 코드로 생성하기</title>
    </head>
    <body>
        <section id="wrap">
            <header>
                <h1 class="logo-title">
                    <span class="main"><img src="../../images/logo_egloos.png" width="105" height="34" alt="이글루스"></span>
                </h1>
                <div class="user-info">
                    <strong class="name">권남</strong> 님 (<strong class="name">kwon37xi</strong>)
                </div>
            </header>
            <main>
                <article class="post-wrap">
                    <!-- 게시물 정보 : 날짜 -->
                    <div class="post-info">
                        <span class="time">2016-01-02 14:09:30</span>
                    </div>
                    <!-- 게시물 제목 -->
                    <h2 class="post-title">동적 Native SQL 생성 어떻게 할까 - 순수 Java 코드로 생성하기</h2>
                    <!-- 게시물 본문 -->
                    <div class="post-body">
                        <div class="content">앞서 <a href="http://kwon37xi.egloos.com/7048211" target="_blank">Freemarker Dynamic QL&nbsp;Builder</a>에 이어, <span style="color:#ff0000;"><strong>순수 Java 코드</strong></span>로 동적 Native SQL/JPQL/HQL을 생성하는 방법에 대한 고민의 결과를 이제서야 공유한다.<br><br>나는 어쩔 수 없이 동적 NativeSQL을 작성해야하는 상황에서라도 MyBatis/iBatis나 Freemarker 같은 외부 템플릿을 사용하는 것을 좋아하지 않는 편이다.<br><br>일단 로직이 없는 정적 SQL의 경우 템플릿을 사용할 이유가 없고, 로직이 존재하는 SQL은 템플릿에서 처리 할 수 없는 로직이 분명히 존재하기 때문에 템플릿과  Java 코드간의 로직 분할이 발생하게 되고 이로인해 로직을 수정해야 할 때 둘 중 한 곳을 간과하여 버그를 만들기 쉬워진다. 또한 Code Coverage 측정이 안 되어 코드에 대한 확신감도 떨어진다.<br><br>MyBatis를 사용한다 해도 가급적 <a href="http://mybatis.org/mybatis-3/ko/statement-builders.html" target="_blank">SQL Builder 클래스</a>를 통해 Java 기반으로 쿼리를 생성하라고 권하고 싶다(물론 이 경우 DBA와의 협업이 어려워지는데, 솔직히  코드 작성하면서 DBA에게 MyBatis XML 얼마나 보여주는지 생각해보면 거의 없을 것이다).<br><br>다음과 같은 순서로 살펴본다.<br><br><ol><li><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html" target="_blank">java.util.StringBuilder</a>를 사용하는 기본적인 방법을 알아보고,</li><li>StringBuilder 기반으로 <a href="https://github.com/kwon37xi/string-builder-ql-params" target="_blank">string-builder-ql-params</a>를 통해 좀 더 쉽게 하는 방법</li><li>아예 StringBuilder를 개선한 <a href="https://github.com/kwon37xi/underscore-builder" target="_blank">UnderscoreStringBuilder</a>라는 것을 통해 처리하는 방법</li><br></ol><br>3번은 사족같은 것이고, 2번까지만 봐도 도움이 많이 될 것 같다.<br><br><h2>1. StringBuilder로 동적 SQL만들기</h2><br><a href="http://kwon37xi.egloos.com/7048211" target="_blank">지난 글</a>에서 말했듯이 동적 SQL 생성의 핵심은 동적으로 쿼리 문자열을 만드는데 있는 것이 아니라 그렇게 만들어진 쿼리에 파라미터를 바인딩(binding)하는 것에 있다.<br><br>동적 문자열 생성은 StringBuilder 만으로도 충분하다. 여기에 보태어 <strong>순서대로 쿼리 파라미터 객체를 저장할 <code>List&lt;Object&gt; params</code> 객체</strong>가 있으면 된다. 아래와 같은 형태가 될 것이다.<br><br>먼저 아래와 같은 데이터 객체들이 존재한다고 하자.<br><blockquote class="src">User&nbsp;user&nbsp;=&nbsp;new&nbsp;User();<br>// User.COLUMNS<br>public static final String[] COLUMNS = new String[]{"user_id", "name", "email", "birthday", "mobile_phone", "home_phone", "address", "zip_code"};<br><br>user.setUserId(10001L);<br>user.setName("UnderscoreQlParams");<br>user.setBirthday(new&nbsp;SimpleDateFormat("yyyy/MM/dd").parse("2015/12/11"));<br>user.setEmail("someone@email.com");<br><br>List&lt;String&gt;&nbsp;zipCodes&nbsp;&nbsp;=&nbsp;Arrays.asList("12345",&nbsp;"56789",&nbsp;"58391");<br></blockquote><br>이제 이를 가지고 쿼리를 생성하면,<br><blockquote class="src">import&nbsp;static&nbsp;org.apache.commons.lang3.StringUtils.isNotEmpty;<br>import&nbsp;static&nbsp;org.apache.commons.lang3.StringUtils.join;<br><br>StringBuilder&nbsp;sb&nbsp;=&nbsp;new&nbsp;StringBuilder();<br><span style="color:#ff0000;"><strong>List&lt;Object&gt;&nbsp;params&nbsp;=&nbsp;new&nbsp;ArrayList&lt;Object&gt;();</strong></span><br>sb<br>&nbsp;&nbsp;.append("SELECT&nbsp;")<br>&nbsp;&nbsp;.append(join(User.COLUMNS,&nbsp;",&nbsp;"))<br>&nbsp;&nbsp;.append("\n")<br>&nbsp;&nbsp;.append("FROM&nbsp;users&nbsp;as&nbsp;u\n");<br><br><strong>sb.append("WHERE&nbsp;1&nbsp;=&nbsp;1");&nbsp;//&nbsp;BUG!!&nbsp;no&nbsp;spaces.</strong><br>if&nbsp;(user.getUserId()&nbsp;!=&nbsp;null)&nbsp;{<br>&nbsp;&nbsp;sb.append("AND&nbsp;user_id&nbsp;=&nbsp;?&nbsp;\n");<br>&nbsp;&nbsp;<span style="color:#ff0000;"><strong>params.add(user.getUserId());</strong></span><br>}<br>if&nbsp;(isNotEmpty(user.getName()))&nbsp;{<br>&nbsp;&nbsp;sb.append("AND&nbsp;name&nbsp;=&nbsp;?&nbsp;\n");<br>&nbsp;&nbsp;params.add(user.getName());<br>}<br>if&nbsp;(user.getBirthday()&nbsp;!=&nbsp;null)&nbsp;{<br>&nbsp;&nbsp;sb.append("AND&nbsp;birthday&nbsp;=&nbsp;?&nbsp;\n");<br>&nbsp;&nbsp;params.add(user.getBirthday());<br>}<br>// IN Parameter 생성<br><strong>if&nbsp;(CollectionUtils.isNotEmpty(zipCodes))&nbsp;{<br>&nbsp;&nbsp;List&lt;String&gt;&nbsp;inParams&nbsp;=&nbsp;new&nbsp;ArrayList&lt;String&gt;(zipCodes.size());<br>&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;zipCodes.size();&nbsp;i++)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;inParams.add("?");<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;sb.append(String.format("AND&nbsp;zip_code&nbsp;IN&nbsp;(%s)",&nbsp;StringUtils.join(inPar",")));<br>&nbsp;&nbsp;params.addAll(zipCodes);</strong><br>}<br><br>sb.append("LIMIT&nbsp;10");<br></blockquote><br><br>List 하나만 추가해도 그런대로 괜찮은 동적 SQL 생성이 가능해진다. <code>sb.toString()</code>으로 동적으로 생성된 SQL문자열을 가져다가 <code>params</code>에 저장된 각 파라미터 객체를 <code>PreparedStatement.setObject(index, value)</code>(index는 1부터시작)로 저장만 해주면된다. 지금까지 문자열을 더해가며(<code>+</code>) 작업했다면 위 방식으로만 해도 어느정도 괜찮아 진다.<br><br>하지만 위에서 굵은 글씨체로 된 부분을 보면 뭔가 문제가 있음을 알 수 있다.<br><br><ol><li>Java Code 사이에서 SQL의 가독성이 떨어지다보니 공백 추가를 잠시 잊을 경우 곧바로 잘못된 SQL을 생성하게 된다. 위 쿼리의 경우 조건에 따라 <code>WHERE 1 = 1AND user_id = ?</code> 이렇게 공백없이 붙어버린 잘못된 쿼리가 생성된다.</li><li><code>WHERE</code> 조건에 대해 언제 AND, OR가 올지 몰라 <code>1 = 1</code>로 방어해줘야 한다. 하지만 대부분의 DB는 최적화가 잘 돼서 이로인한 성능저하는 없다고한다. 따라서 이 문제는 사실상 무시해도 된다.</li><li><code>IN</code>조건의 파라미터를 생성하는 것이 굉장히 복잡하다.</li></ol><br>이제 여기서 첫번째와 두번째 문제는 마지막에 알아보고, 세번째 문제를 해결해보자.<br>그리고 IN 조건절의 경우 Java 8에서 좀 더 간결하게 만들 수도 있는데, 그에 대해서는 논외로한다.<br><br><h2>2. StringBuilder 기반으로 <a href="https://github.com/kwon37xi/string-builder-ql-params" target="_blank">string-builder-ql-params</a>를 통해 좀 더 쉽게 하는 방법</h2><br>위 코드의 <code>List&lt;Object&gt; params</code>에 파라미터를 추가하고 더불어 <code>IN</code> 조건절의 문자열과 파라미터 추가를 좀 더 쉽게 할 수 있는 도우미 클래스를 만들면 쉽게 해결 가능하다. <a href="https://github.com/kwon37xi/string-builder-ql-params" target="_blank">string-builder-ql-params</a>라는 프로젝트에 만들어서 Maven Repository에 올려두었는데, 이 프로젝트 전체를 사용할 필요까진 없고 그냥 <a href="https://github.com/kwon37xi/string-builder-ql-params/blob/master/src/main/java/kr/pe/kwonnam/dynamicql/stringbuilderqlparams/DynamicQlParams.java" target="_blank">DynamicQlParams.java</a>클래스 한개만 복사해 자기 프로젝트에 넣고 사용해도 된다.<br><code>DynamicQlParams</code>는 그 안에 파라미터 List객체와 <code>param(Object param)</code>, <code>inParams(Iterable|Object[])</code>, <code>bindParameters(PreparedStatement)</code>,<code>getParameters()</code>등이 있다.<br><br>이 클래스와 <code>StringBuilder</code>를 조합하면 다음과 같이 된다.<br><br><blockquote class="src">import&nbsp;org.apache.commons.collections4.CollectionUtils;<br>import&nbsp;org.apache.commons.lang3.StringUtils;<br>import&nbsp;static&nbsp;java.lang.String.format;<br><br>StringBuilder&nbsp;builder&nbsp;=&nbsp;new&nbsp;StringBuilder();<br>DynamicQlParams&nbsp;dqp&nbsp;=&nbsp;new&nbsp;DynamicQlParams();<br><br>builder<br>&nbsp;&nbsp;.append("SELECT&nbsp;")<br>&nbsp;&nbsp;.append(StringUtils.join(User.COLUMNS,&nbsp;",&nbsp;")).append("\n")<br>&nbsp;&nbsp;.append("FROM&nbsp;users&nbsp;as&nbsp;u\n")<br>&nbsp;&nbsp;.append("WHERE&nbsp;1&nbsp;=&nbsp;1\n");<br><br>if&nbsp;(user.getUserId()&nbsp;!=&nbsp;null)&nbsp;{<br>&nbsp;&nbsp;<strong>builder.append(format("AND&nbsp;user_id&nbsp;=&nbsp;%s&nbsp;%n",&nbsp;dqp.param(user.getUserId())));</strong><br>}<br>if&nbsp;(StringUtils.isNotEmpty(user.getName()))&nbsp;{<br>&nbsp;&nbsp;builder.append(format("AND&nbsp;name&nbsp;=&nbsp;%s&nbsp;%n",&nbsp;dqp.param(user.getName())));<br>}<br>if&nbsp;(user.getBirthday()&nbsp;!=&nbsp;null)&nbsp;{<br>&nbsp;&nbsp;builder.append(format("AND&nbsp;birthday&nbsp;=&nbsp;%s&nbsp;%n",&nbsp;dqp.param(user.getBirthday())));<br>}<br>if&nbsp;(CollectionUtils.isNotEmpty(zipCodes))&nbsp;{<br>&nbsp;&nbsp;<strong>builder.append(format("AND&nbsp;zip_code&nbsp;in&nbsp;(%s)&nbsp;%n",dqp.inParams(zipCodes)));</strong><br>}<br><br>builder.append("LIMIT&nbsp;").append(dqp.param(10));<br><br>PreparedStatement&nbsp;preparedStatement&nbsp;=&nbsp;conn.prepareStatement(builder.toString());<br><strong>dqp.bindParameters(preparedStatement);</strong>&nbsp;//&nbsp;bind&nbsp;parameters&nbsp;to&nbsp;preparedStatement<br></blockquote><br><br><code>DynamicQlParams</code>와 <code>String.format</code>을 조합했더니 좀 더 가독성 좋고 편리하게 동적 SQL을 생성하게 되었다.<br>이것 말고도 <a href="https://github.com/kwon37xi/string-builder-ql-params/blob/master/src/main/java/kr/pe/kwonnam/dynamicql/stringbuilderqlparams/DynamicNamedQlParams.java" target="_blank">DynamicNamedQlParams</a>도 만들었다. Spring JDBCTempalte과 JPQL, HQL은 Named Parameter를 지원하기 때문이 이를 사용할 수도 있다.<br>하지만 Named Parameter는 그 자체가 정적 SQL에서 편리한 파라미터 바인딩을 위한 것이지 동적 SQL에서는 불필요한 기능으로 보인다.<br><br>여기서도 사실 구문 사이사이의 공백을 하나라도 잊어버렸을 때의 잘못된 SQL을 생성하는 문제는 해결이 안된 상태이다. 그리고 가독성도 조금만 더 높였으면 좋겠다.<br><br><h3>3.  StringBuilder를 개선한 <a href="https://github.com/kwon37xi/underscore-builder" target="_blank">UnderscoreStringBuilder</a>를 사용해보기</h3><br>사실 내가 보기엔 나처럼 정말 어쩌다가 한 두번 동적 NativeSQL을 생성하는 사람은 2번째 방법만 사용해도 괜찮아 보인다. 그래도 학습삼아 좀 오버를 해보았다. 아예 StringBuilder를 대체하는 <a href="https://github.com/kwon37xi/underscore-builder" target="_blank">UnderscoreStringBuilder</a>라는 것을 만들고 거기에 동적 Native SQL생성시 StringBuilder가 가진 단점들들 커버해 줄 수 있는 기능을 넣은 것이다.<br>아래와 같이 의존성을 추가하고 살펴보도록 하자.<br><blockquote class="src">compile&nbsp;'"kr.pe.kwonnam.underscorebuilder:underscore-ql-params:0.1"<br></blockquote><br><br>이 프로젝트는 딱 두 개의 핵심 클래스로 이뤄진다. <code>StringBuilder</code>를 대체하는 <a href="https://github.com/kwon37xi/underscore-builder/blob/master/underscore-string-builder/src/main/java/kr/pe/kwonnam/underscore/stringbuilder/UnderscoreStringBuilder.java" target="_blank">UnderscoreStringBuilder</a>와, 2번에서 <code>DynamicQlParams</code>의 역할을 하는 <a href="https://github.com/kwon37xi/underscore-builder/blob/master/underscore-ql-params/src/main/java/kr/pe/kwonnam/underscore/qlparams/UnderscoreQlParams.java" target="_blank">UnderscoreQlParams</a> 클래스이다.<br><br><code>StringBuilder.append()</code> 역할을 하는 <code>UnderscoreStringBuilder</code>의 핵심 메소드는 <code>__</code> 그 중에서도 아래 메소드 이다.<br><blockquote class="src">UnderscoreStringBuilder.__(boolean&nbsp;appendable,&nbsp;A&nbsp;appendee,<br>&nbsp;&nbsp;&nbsp;UnderscoreTransformer&lt;A&gt;&nbsp;transformer,&nbsp;UnderscoreTransformer&lt;?&nbsp;super&nbsp;CharSequence&gt;...&nbsp;extraTransformers)<br></blockquote><br>왜 이름이 <code><strong>Underscore</strong>StringBuilder</code>인지 알 것 같다. <code>append()</code>보다는 가독성이 좋을 것 같아서 이렇게 했는데, 실제로 그런지는 잘 모르겠다.<br><br>이 메소드에서 <code>appendable,transformer,extraTransformers</code>는 모두 생략가능하다.<br><ul><li><code>appendable</code> : <code>appendee</code>를 추가할지 여부</li><li><code>appendee</code> : 문자열에 추가할 객체. 내부적으로 <code>StringBuilder.append()</code> 호출함.</li><li><code>transformer,extraTransformers</code> : <code>appendee</code>를 추가하기 전에 변환 작업을 한다. 지정된 transformer의 순서대로 연달아 변환한다.</li></ul><br><br><code>UnderscoreQlParams</code>는 여기서 동적 쿼리 생성으로 변환하는 <code>transformer</code> 객체를 생성하고 상태를 저장하는 역할을 한다. 일단 <code>UnderscoreQlParams</code>없이 순수 문자열 기반으로 쿼리를 생성하면 다음과 같은 형태가 된다.<br><blockquote class="src"><strong>import static kr.pe.kwonnam.underscore.stringbuilder.UnderscoreStringBuilderTransformers.*;</strong><br>import static kr.pe.kwonnam.underscore.stringbuilder.transformers.trim.TrimOpts.trimOpts;<br>import static org.apache.commons.lang3.StringUtils.isNotEmpty;<br><br>UnderscoreStringBuilder&nbsp;=&nbsp;usb&nbsp;=&nbsp;new&nbsp;UnderscoreStringBuilder();<br>final&nbsp;SimpleDateFormat&nbsp;sdf&nbsp;=&nbsp;new&nbsp;SimpleDateFormat("yyyy-MM-dd&nbsp;HH:mm:ss");<br>usb<br>&nbsp;&nbsp;&nbsp;&nbsp;.__("SELECT&nbsp;").<strong>suffixNewLine()</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;.__(",&nbsp;",&nbsp;join(User.COLUMNS))<br>&nbsp;&nbsp;&nbsp;&nbsp;.__("FROM&nbsp;users&nbsp;as&nbsp;u")<br>&nbsp;&nbsp;&nbsp;&nbsp;.sub(user&nbsp;!=&nbsp;null,&nbsp;new&nbsp;UnderscoreSubBuild()&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;subbuild(UnderscoreStringBuilder&nbsp;underscoreSubBuilder)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;underscoreSubBuilder.<strong>prefix("\n&nbsp;&nbsp;&nbsp;&nbsp;"</strong>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.__(user.getUserId()&nbsp;!=&nbsp;null,&nbsp;<strong>"AND&nbsp;user_id&nbsp;=&nbsp;%d",&nbsp;format(user.getUserId())</strong>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.__(isNotEmpty(user.getName()),&nbsp;"AND&nbsp;name&nbsp;=&nbsp;'%s'",&nbsp;format(user.getName()))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.__(user.getBirthday()&nbsp;!=&nbsp;null,&nbsp;"AND&nbsp;birthday&nbsp;=&nbsp;'%s'",&nbsp;format(sdf.format(user.getBirthday())))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.__(CollectionUtils.isNotEmpty(zipCodes),&nbsp;<strong>",&nbsp;",&nbsp;join(zipCodes),&nbsp;wrap("AND&nbsp;zip_code&nbsp;in&nbsp;(",&nbsp;")")</strong>);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;trim(trimOpts().prefix("WHERE&nbsp;").prefixOverrides("AND&nbsp;",&nbsp;"OR&nbsp;")))<br>&nbsp;&nbsp;&nbsp;&nbsp;.__("LIMIT&nbsp;10");<br></blockquote><br><br><code>UnderscoreStringBuilderTransformers</code>는 각종 <code>UnderscoreTransformer</code> 객체를 쉽게 생성해주는 static method가 있는 클래스이다. 미리 준비한 transformer들은 <code>format, dateFormat, join, wrap, multiply, trim</code>등이다.<br>위 코드는 파라미터 바인딩이 필요없는 일반 SQL 문자열을 생성한 것이고, 진짜 목표인 <code>?</code> 혹은 <code>?1,?2,...</code> 기반의 PreparedStatement 지원 동적 SQL을 생성해보면 다음과 같은 형태가 된다.<br><blockquote class="src">import static kr.pe.kwonnam.underscore.stringbuilder.UnderscoreStringBuilderTransformers.join;<br>import static kr.pe.kwonnam.underscore.stringbuilder.UnderscoreStringBuilderTransformers.trim;<br>import static kr.pe.kwonnam.underscore.stringbuilder.transformers.trim.TrimOpts.trimOpts;<br>import static org.apache.commons.lang3.StringUtils.isNotEmpty;<br><br>UnderscoreStringBuilder&nbsp;usb&nbsp;=&nbsp;new&nbsp;UnderscoreStringBuilder();<br>UnderscoreQlParams&nbsp;qlParams&nbsp;=&nbsp;new&nbsp;UnderscoreQlParams();<br>usb<br>&nbsp;&nbsp;&nbsp;&nbsp;.__("SELECT&nbsp;")<strong>.suffixNewLine()</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;.__(<strong>",&nbsp;",&nbsp;join(User.COLUMNS)</strong>)<br>&nbsp;&nbsp;&nbsp;&nbsp;.__("FROM&nbsp;users&nbsp;as&nbsp;u")<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>.sub(user&nbsp;!=&nbsp;null,&nbsp;new&nbsp;UnderscoreSubBuild()</strong>&nbsp;{ // user != null일 때만 아래 블럭이 실행되고 문자열과 파라미터 추가됨.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;subbuild(UnderscoreStringBuilder&nbsp;underscoreSubBuilder)&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;underscoreSubBuilder.<strong>prefix("\n&nbsp;&nbsp;&nbsp;")</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.__(user.getUserId()&nbsp;!=&nbsp;null,<strong>&nbsp;"AND&nbsp;user_id&nbsp;=&nbsp;%s",&nbsp;qlParams.params(user.getUserId())</strong>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.__(isNotEmpty(user.getName()),&nbsp;"AND&nbsp;name&nbsp;=&nbsp;%s",&nbsp;qlParams.params(user.getName()))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.__(user.getBirthday()&nbsp;!=&nbsp;null,&nbsp;"AND&nbsp;birthday&nbsp;=&nbsp;%s",&nbsp;qlParams.params(user.getBirthday()))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.__(CollectionUtils.isNotEmpty(zipCodes),&nbsp;<strong>"AND&nbsp;zip_code&nbsp;in&nbsp;(%s)",&nbsp;qlParams.inParams(zipCodes)</strong>);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;trim(trimOpts().prefix("WHERE&nbsp;").prefixOverrides("AND&nbsp;",&nbsp;"OR&nbsp;")))<br>&nbsp;&nbsp;&nbsp;&nbsp;.__("LIMIT&nbsp;%s",&nbsp;qlParams.params(10));<br><br>log.info("UnderscoreStringBuilder with UnderscoreQlParams : {}", <strong>usb.toString()</strong>); // 생성된 SQL<br>log.info("Query Parameters : {}", <strong>qlParams.getQueryParameters()</strong>); // 바인딩할 Parameters<br></blockquote><br><br><code>params, inParams</code>는 내부적으로 <code>String.format</code>을 호출한다. 따라서 앞에 추가할 문자열도 포맷팅 문자열로 만들어줘야 한다. 간단하다. <span style="color:#ff0000;"><strong>파라미터 바인딩 물음표가 들어갈 부분을 <code>%s</code>로 해주기만 하면 된다</strong></span>.<br><br><code>UnderscoreStringBuilder.prefix()|suffix()</code>는 <code>prefixOff()|suffixOff()</code>가 호출될 때까지 모든 문자열 덧붙이기 할 때마다 지정된 문자열을 앞/뒤에 붙여준다. 이를 통해 공백을 까먹어서 생기는 문제를 해소해준다.<br>그리고 <code>trim transformer</code>를 통해 MyBatis <code>&lt;trim&gt;</code>와 동일한 효과를 낼 수 있게 하였다.<br><code>sub</code> 부분은 Java 8 Lambda를 사용하면 좀 더 간결해진다.<br><br>지금까지 생성된 쿼리를 보여준 적이 없는데, log 출력 내용은 다음과 같다.<br><br><blockquote class="src">UnderscoreStringBuilder&nbsp;with&nbsp;UnderscoreQlParams&nbsp;:&nbsp;SELECT&nbsp;user_id,&nbsp;name,&nbsp;email,&nbsp;birthday,&nbsp;mobile_phone,&nbsp;home_phone,&nbsp;address,&nbsp;zip_code<br>FROM&nbsp;users&nbsp;as&nbsp;u<br>WHERE&nbsp;user_id&nbsp;=&nbsp;?<br>&nbsp;&nbsp;&nbsp;AND&nbsp;name&nbsp;=&nbsp;?<br>&nbsp;&nbsp;&nbsp;AND&nbsp;birthday&nbsp;=&nbsp;?<br>&nbsp;&nbsp;&nbsp;AND&nbsp;zip_code&nbsp;in&nbsp;(?,&nbsp;?,&nbsp;?)<br>LIMIT&nbsp;?<br><br>Query&nbsp;Parameters&nbsp;:&nbsp;[10001,&nbsp;UnderscoreQlParams,&nbsp;Fri&nbsp;Dec&nbsp;11&nbsp;00:00:00&nbsp;KST&nbsp;2015,&nbsp;12345,&nbsp;56789,&nbsp;58391,&nbsp;10]<br></blockquote><br><br>코드를 보면 맨 위에서 도출했던 세가지 문제가 일단은 다 해결된 것을 볼 수 있다.<br><br>JPQL/HQL의 <code>?1, ?2, ..</code> 형태로 쿼리를 생성하고자 한다면 <code>UnderscoreQlParams.withPositionalIndex()</code>를 사용하면 된다.<br><br>사실 다 만들어놓고 보니 굳이 이렇게까지 해야하나 싶긴한데, 만드는 과정 자체가 학습이 많이 되어서 만족한다.<br></div>
                        <div class="post-footer">
                            <button class="btn" onclick="button_click();">목록</button>
                        </div>
                    </div>
                </article>
            </main>
        </section>

        <script src="https://code.jquery.com/jquery-3.5.1.js"></script>

        <script>
            function button_click() {
                if(history.length > 1) {
                    history.back();
                } else {
                    document.location.href = "../../블로그포스트목록.html";
                }
            }
        </script>
    </body>
</html>
